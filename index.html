<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slingshot City: Gotham Hunt</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: pixelated;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            color: #FFD700;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 2px 2px 0px #000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 2px;
            background-color: #FF0000;
            border: 1px solid #FFD700;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            box-shadow: 0 0 4px #FFD700;
        }

        .controls-area {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px; 
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
        }

        @media (min-width: 1024px) { .joystick-base { opacity: 0.2; } }

        .joystick-stick {
            width: 50px;
            height: 50px;
            background: rgba(50, 50, 50, 0.5);
            border: 1px solid #FFD700;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* TELA DE INICIO (Overlay para ativar som) */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            pointer-events: auto;
        }
        #start-btn {
            padding: 20px 40px;
            font-size: 24px;
            background-color: #FFD700;
            color: #000;
            border: 4px solid #fff;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 20px #FFD700;
        }

        #message {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: #eee;
            font-size: 18px;
            text-shadow: 1px 1px 2px black;
            background-color: rgba(0,0,0,0.9); 
            padding: 20px; 
            display: none; 
            border-top: 2px solid #FFD700; 
            border-bottom: 2px solid #FFD700; 
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color:#FFD700; margin-bottom:20px; text-shadow: 2px 2px #000;">BAT-HUNT 3D</h1>
        <div id="start-btn">TOCAR PARA INICIAR</div>
        <p style="color:#aaa; margin-top:20px;">Ligue o som üîä</p>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <span id="score-display">MORCEGOS: 0 / 25</span>
            <span>ACHE A SA√çDA</span>
        </div>
        
        <div id="crosshair" class="crosshair"></div>
        <div id="message"></div>

        <div class="controls-area">
            <div id="joy-left" class="joystick-base">
                <div id="stick-left" class="joystick-stick"></div>
            </div>
            <div id="joy-right" class="joystick-base">
                <div id="stick-right" class="joystick-stick" style="background: rgba(255, 215, 0, 0.2)"></div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas" width="320" height="240"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score-display');
    const crosshair = document.getElementById('crosshair');
    const messageDiv = document.getElementById('message');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');

    const joyLeftBase = document.getElementById('joy-left'); const stickLeft = document.getElementById('stick-left');
    const joyRightBase = document.getElementById('joy-right'); const stickRight = document.getElementById('stick-right');

    const SCREEN_WIDTH = 320;
    const SCREEN_HEIGHT = 240;
    
    // --- SPRITE BATMAN ---
    const spriteSize = 64;
    const batmanCanvas = document.createElement('canvas');
    batmanCanvas.width = spriteSize; batmanCanvas.height = spriteSize;
    const bCtx = batmanCanvas.getContext('2d');
    bCtx.fillStyle = '#000'; bCtx.beginPath(); bCtx.moveTo(16, 20); bCtx.lineTo(48, 20); bCtx.lineTo(54, 60); bCtx.lineTo(32, 55); bCtx.lineTo(10, 60); bCtx.fill();
    bCtx.fillStyle = '#444'; bCtx.fillRect(20, 20, 24, 30);
    bCtx.fillStyle = '#000'; bCtx.beginPath(); bCtx.moveTo(22, 20); bCtx.lineTo(22, 8); bCtx.lineTo(26, 12); bCtx.lineTo(38, 12); bCtx.lineTo(42, 8); bCtx.lineTo(42, 20); bCtx.fill(); bCtx.fillRect(22, 12, 20, 14);
    bCtx.fillStyle = '#FFD700'; bCtx.fillRect(20, 48, 24, 4);
    bCtx.beginPath(); bCtx.ellipse(32, 30, 8, 5, 0, 0, Math.PI * 2); bCtx.fill();
    bCtx.fillStyle = '#000'; bCtx.beginPath(); bCtx.moveTo(26,28); bCtx.lineTo(38,28); bCtx.lineTo(32,33); bCtx.fill();
    bCtx.fillStyle = '#fff'; bCtx.fillRect(26, 16, 4, 2); bCtx.fillRect(34, 16, 4, 2);
    bCtx.fillStyle = '#F1C27D'; bCtx.fillRect(28, 22, 8, 4);

    const PALETTE = {
        floor: '#1a1a1a', skyTop: '#050505', skyBottom: '#202020',
        wallGray: '#555', wallGrayDark: '#333',
        obstacle: '#2F4F4F', obstacleDark: '#1c2e2e',
        finish: '#00FF00'
    };

    let kills = 0; const totalTargets = 25;
    let moveSpeed = 0.15; let rotSpeed = 0.05; let gameOver = false;
    const mapSize = 50; const worldMap = [];
    let sprites = [];
    let zBuffer = new Array(SCREEN_WIDTH).fill(0);

    // --- SISTEMA DE √ÅUDIO (BATMAN THEME 60s) ---
    let audioCtx = null;
    let isMusicPlaying = false;

    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (!isMusicPlaying) {
            isMusicPlaying = true;
            playBatTheme();
        }
    }

    function playBatTheme() {
        if (!audioCtx) return;
        
        const tempo = 135; // BPM rapidinho
        const noteDuration = 60 / tempo / 2; // Colcheias
        
        // Loop Crom√°tico Descendente (O famoso riff)
        // B -> Bb -> A -> Ab ...
        const notes = [
            246.94, 246.94, 246.94, 246.94, 246.94, 246.94, 246.94, 246.94, // B3
            233.08, 233.08, 233.08, 233.08, 233.08, 233.08, 233.08, 233.08, // Bb3
            220.00, 220.00, 220.00, 220.00, 220.00, 220.00, 220.00, 220.00, // A3
            207.65, 207.65, 207.65, 207.65, 207.65, 207.65, 207.65, 207.65  // Ab3 (G#3)
        ];

        let time = audioCtx.currentTime;

        // Tocar o loop
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sawtooth'; // Som retr√¥
            osc.frequency.value = freq;
            
            // Envelope curto (staccato)
            gain.gain.setValueAtTime(0.1, time + i * noteDuration);
            gain.gain.exponentialRampToValueAtTime(0.01, time + i * noteDuration + 0.1);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start(time + i * noteDuration);
            osc.stop(time + i * noteDuration + 0.15);
        });

        // Agendar pr√≥ximo loop
        if(!gameOver) {
            setTimeout(playBatTheme, (notes.length * noteDuration * 1000) - 20); // Pequeno ajuste de delay
        }
    }

    startBtn.addEventListener('click', () => {
        startScreen.style.display = 'none';
        initAudio();
    });
    startBtn.addEventListener('touchstart', () => {
        startScreen.style.display = 'none';
        initAudio();
    });


    // --- GERA√á√ÉO DE CIDADE ---
    function generateHunterCity() {
        for(let x=0; x<mapSize; x++) { worldMap[x] = []; for(let y=0; y<mapSize; y++) { worldMap[x][y] = (x+y)%3 + 1; } }
        function carve(x1, y1, x2, y2) { let startX = Math.min(x1, x2); let endX = Math.max(x1, x2); let startY = Math.min(y1, y2); let endY = Math.max(y1, y2); for(let x = startX-1; x <= endX+1; x++) { for(let y = startY-1; y <= endY+1; y++) { if(x>0 && x<mapSize-1 && y>0 && y<mapSize-1) worldMap[x][y] = 0; }}}
        carve(24, 48, 24, 20); carve(10, 20, 40, 20); carve(40, 20, 40, 40); carve(40, 40, 30, 40); carve(30, 40, 30, 48); carve(10, 20, 10, 5); carve(10, 12, 18, 12); carve(10, 5, 2, 5); carve(2, 5, 2, 15);
        worldMap[22][40] = 0; worldMap[26][30] = 0; worldMap[24][18] = 4; worldMap[35][20] = 4; worldMap[16][13] = 4;
        worldMap[1][15] = 8; worldMap[2][15] = 8; worldMap[3][15] = 8;

        sprites = [
            {x:22.5, y:40.5, active:true}, {x:26.5, y:30.5, active:true}, {x:24.5, y:17.5, active:true}, {x:36.5, y:20.5, active:true}, {x:18.5, y:12.5, active:true}, {x:41.5, y:41.5, active:true}, {x:29.5, y:41.5, active:true}, {x:23.5, y:45.5, active:true}, {x:25.5, y:45.5, active:true}, {x:9.5, y:21.5, active:true}, {x:11.5, y:19.5, active:true}, {x:41.5, y:25.5, active:true}, {x:39.5, y:35.5, active:true}, {x:10.5, y:4.5, active:true}, {x:2.5, y:4.5, active:true}, {x:4.5, y:14.5, active:true}, {x:1.5, y:10.5, active:true}, {x:15.5, y:11.5, active:true}, {x:15.5, y:13.5, active:true}, {x:31.5, y:47.5, active:true}, {x:24.5, y:25.5, active:true}, {x:20.5, y:20.5, active:true}, {x:30.5, y:20.5, active:true}, {x:45.5, y:20.5, active:true}
        ];
        posX = 24.5; posY = 47.5; dirX = 0; dirY = -1; planeX = -0.66; planeY = 0;
    }
    generateHunterCity();

    let isShooting = false; let shootFrame = 0; let rockFlying = false; let rockSize = 0; let rockY = 0;
    let touchMoveY = 0, touchMoveX = 0, touchTurn = 0;
    const keys = { w:false, s:false, a:false, d:false, ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, Space:false };

    document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key) || e.code === "Space") { if(e.code === "Space") { playerShoot(); return; } keys[e.key] = true; } });
    document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
    const controls = { left: { id: null, startX: 0, startY: 0, active: false }, right: { id: null, startX: 0, startY: 0, startTime: 0, active: false } };
    function getRelativePos(touch, element) { const rect = element.getBoundingClientRect(); return { x: touch.clientX - (rect.left + rect.width / 2), y: touch.clientY - (rect.top + rect.height / 2) }; }
    document.addEventListener('touchstart', (e) => { if(gameOver) return; e.preventDefault(); for (let i=0; i<e.changedTouches.length; i++) { let t = e.changedTouches[i]; let rectL = joyLeftBase.getBoundingClientRect(); if (t.clientX >= rectL.left && t.clientX <= rectL.right && t.clientY >= rectL.top && t.clientY <= rectL.bottom && !controls.left.active) { controls.left.id = t.identifier; controls.left.active = true; updateJoystick(t, 'left'); continue; } if (t.clientX >= window.innerWidth/2 && !controls.right.active) { controls.right.id = t.identifier; controls.right.active = true; controls.right.startX = t.clientX; controls.right.startY = t.clientY; controls.right.startTime = Date.now(); updateJoystick(t, 'right'); } } }, {passive: false});
    document.addEventListener('touchmove', (e) => { if(gameOver) return; e.preventDefault(); for (let i=0; i<e.changedTouches.length; i++) { let t = e.changedTouches[i]; if (t.identifier === controls.left.id) updateJoystick(t, 'left'); if (t.identifier === controls.right.id) updateJoystick(t, 'right'); } }, {passive: false});
    document.addEventListener('touchend', (e) => { e.preventDefault(); for (let i=0; i<e.changedTouches.length; i++) { let t = e.changedTouches[i]; if (t.identifier === controls.left.id) { controls.left.active = false; controls.left.id = null; resetJoystick('left'); touchMoveX = 0; touchMoveY = 0; } if (t.identifier === controls.right.id) { let duration = Date.now() - controls.right.startTime; let dist = Math.hypot(t.clientX - controls.right.startX, t.clientY - controls.right.startY); if (duration < 250 && dist < 20) playerShoot(); controls.right.active = false; controls.right.id = null; resetJoystick('right'); touchTurn = 0; } } });
    function updateJoystick(touch, side) { const base = side === 'left' ? joyLeftBase : joyRightBase; const stick = side === 'left' ? stickLeft : stickRight; let pos = getRelativePos(touch, base); const maxDist = 40; const dist = Math.hypot(pos.x, pos.y); const angle = Math.atan2(pos.y, pos.x); let visualX = pos.x; let visualY = pos.y; if (dist > maxDist) { visualX = Math.cos(angle) * maxDist; visualY = Math.sin(angle) * maxDist; } stick.style.transform = `translate(calc(-50% + ${visualX}px), calc(-50% + ${visualY}px))`; if (side === 'left') { touchMoveX = visualX / maxDist; touchMoveY = -(visualY / maxDist); } else { touchTurn = visualX / maxDist; } }
    function resetJoystick(side) { const stick = side === 'left' ? stickLeft : stickRight; stick.style.transform = `translate(-50%, -50%)`; }

    // --- L√ìGICA DE TIRO (HITBOX FINA) ---
    function playerShoot() { 
        if (isShooting || gameOver) return; 
        isShooting = true; shootFrame = 10; rockFlying = true; rockSize = 6; rockY = SCREEN_HEIGHT - 60;
        
        sprites.sort((a, b) => {
            return ((posX - a.x)*(posX - a.x) + (posY - a.y)*(posY - a.y)) - ((posX - b.x)*(posX - b.x) + (posY - b.y)*(posY - b.y));
        });

        for(let i=0; i<sprites.length; i++) {
            let s = sprites[i];
            if (!s.active) continue;

            let spriteX = s.x - posX; let spriteY = s.y - posY;
            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 

            if (transformY > 0) {
                let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
                let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
                
                // CALCULO DE COLIS√ÉO PRECISO (Hitbox Fina)
                let leftEdge = spriteScreenX - spriteWidth / 2;
                
                // Onde est√° a mira (Centro da tela) em rela√ß√£o ao inicio do sprite?
                let crosshairX = SCREEN_WIDTH / 2;
                let offset = crosshairX - leftEdge;
                
                // Transforma essa posi√ß√£o em coordenadas da textura (0 a 64)
                let texX = Math.floor(offset * spriteSize / spriteWidth);

                // A textura tem 64px. O corpo do Batman vai mais ou menos de 16 a 48.
                // As bordas (0-15 e 49-64) s√£o capa/ar, n√£o contam como hit.
                if (texX > 15 && texX < 49) {
                    // Verifica Z-Buffer (se tem parede na frente)
                    if (transformY < zBuffer[Math.floor(crosshairX)] + 0.5 && transformY < 15) {
                        setTimeout(() => { 
                            s.active = false; kills++; 
                            scoreDisplay.innerText = `MORCEGOS: ${kills} / ${totalTargets}`; 
                            crosshair.style.backgroundColor = '#FFD700'; crosshair.style.transform = 'translate(-50%, -50%) scale(2.5)'; 
                            setTimeout(() => { crosshair.style.backgroundColor = '#FF0000'; crosshair.style.transform = 'translate(-50%, -50%) scale(1)'; }, 150); 
                        }, 200);
                        break; 
                    }
                }
            }
        }
    }
    
    function checkWinCondition() { if (worldMap[Math.floor(posX)][Math.floor(posY)] === 8) { gameOver = true; messageDiv.innerHTML = `<h1 style="color:#FFD700">MISS√ÉO CUMPRIDA!</h1><p>Gotham Limpa.</p><p>Impostores: ${kills} / ${totalTargets}</p>`; messageDiv.style.display = 'block'; document.getElementById('start-screen').style.display = 'none'; } }
    
    function gameLoop() { 
        if (!gameOver) { 
            let turnInput = touchTurn; if (keys.ArrowRight) turnInput += 1; if (keys.ArrowLeft) turnInput -= 1; 
            if (turnInput !== 0) { turnInput = Math.max(-1, Math.min(1, turnInput)); let rot = turnInput * rotSpeed; let oldDirX = dirX; dirX = dirX * Math.cos(rot) - dirY * Math.sin(rot); dirY = oldDirX * Math.sin(rot) + dirY * Math.cos(rot); let oldPlaneX = planeX; planeX = planeX * Math.cos(rot) - planeY * Math.sin(rot); planeY = oldPlaneX * Math.sin(rot) + planeY * Math.cos(rot); } 
            let moveYInput = touchMoveY; if (keys.w || keys.ArrowUp) moveYInput += 1; if (keys.s || keys.ArrowDown) moveYInput -= 1; 
            let moveXInput = touchMoveX; if (keys.d) moveXInput += 1; if (keys.a) moveXInput -= 1; 
            let nextX = posX, nextY = posY; 
            if (Math.abs(moveYInput) > 0.1) { let speed = moveYInput * moveSpeed; if(worldMap[Math.floor(posX + dirX * speed)][Math.floor(posY)] <= 0 || worldMap[Math.floor(posX + dirX * speed)][Math.floor(posY)] === 8) posX += dirX * speed; if(worldMap[Math.floor(posX)][Math.floor(posY + dirY * speed)] <= 0 || worldMap[Math.floor(posX)][Math.floor(posY + dirY * speed)] === 8) posY += dirY * speed; } 
            if (Math.abs(moveXInput) > 0.1) { let speed = moveXInput * (moveSpeed * 0.7); let strafeX = -dirY; let strafeY = dirX; if(worldMap[Math.floor(posX + strafeX * speed)][Math.floor(posY)] <= 0 || worldMap[Math.floor(posX + strafeX * speed)][Math.floor(posY)] === 8) posX += strafeX * speed; if(worldMap[Math.floor(posX)][Math.floor(posY + strafeY * speed)] <= 0 || worldMap[Math.floor(posX)][Math.floor(posY + strafeY * speed)] === 8) posY += strafeY * speed; } checkWinCondition(); 
        } 
        if (shootFrame > 0) shootFrame--; else isShooting = false; draw(); requestAnimationFrame(gameLoop); 
    }

    function draw() {
        let gradientSky = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT/2); gradientSky.addColorStop(0, PALETTE.skyTop); gradientSky.addColorStop(1, PALETTE.skyBottom);
        ctx.fillStyle = gradientSky; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
        ctx.fillStyle = PALETTE.floor; ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

        zBuffer.fill(1000); 

        for (let x = 0; x < SCREEN_WIDTH; x++) { 
            let cameraX = 2 * x / SCREEN_WIDTH - 1; let rayDirX = dirX + planeX * cameraX; let rayDirY = dirY + planeY * cameraX;
            let mapX = Math.floor(posX), mapY = Math.floor(posY);
            let sideDistX, sideDistY, deltaDistX = Math.abs(1 / rayDirX), deltaDistY = Math.abs(1 / rayDirY);
            let stepX, stepY, hit = 0, side, hitType = 0;
            if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; } else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
            if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; } else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }
            while (hit === 0) {
                if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; } else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                if (worldMap[mapX][mapY] > 0) { hit = 1; hitType = worldMap[mapX][mapY]; }
            }
            let perpWallDist = side === 0 ? (mapX - posX + (1 - stepX) / 2) / rayDirX : (mapY - posY + (1 - stepY) / 2) / rayDirY;
            zBuffer[x] = perpWallDist;
            let lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
            let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2; if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2; if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;
            let color; if (hitType >= 1 && hitType <= 3) color = side === 1 ? PALETTE.wallGrayDark : PALETTE.wallGray; else if (hitType === 4) color = side === 1 ? PALETTE.obstacleDark : PALETTE.obstacle; else if (hitType === 8) color = PALETTE.finish; else color = '#000';
            ctx.fillStyle = color; ctx.globalAlpha = Math.max(0.1, 1 - perpWallDist / 30); ctx.fillRect(x, drawStart, 1, drawEnd - drawStart); ctx.globalAlpha = 1.0;
        }

        let spriteOrder = [];
        for(let i=0; i<sprites.length; i++) {
            if(!sprites[i].active) continue;
            let dist = ((posX - sprites[i].x)*(posX - sprites[i].x) + (posY - sprites[i].y)*(posY - sprites[i].y));
            spriteOrder.push({ id: i, dist: dist });
        }
        spriteOrder.sort((a,b) => b.dist - a.dist);

        for(let i=0; i<spriteOrder.length; i++) {
            let sprite = sprites[spriteOrder[i].id];
            let spriteX = sprite.x - posX; let spriteY = sprite.y - posY;
            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 
            if (transformY > 0) { 
                let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
                let spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY)); 
                let drawStartY = -spriteHeight / 2 + SCREEN_HEIGHT / 2 + (spriteHeight * 0.25); if (drawStartY < 0) drawStartY = 0;
                let drawEndY = drawStartY + spriteHeight; if (drawEndY >= SCREEN_HEIGHT) drawEndY = SCREEN_HEIGHT - 1;
                let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
                let drawStartX = -spriteWidth / 2 + spriteScreenX; let drawEndX = spriteWidth / 2 + spriteScreenX;
                for(let stripe = Math.floor(drawStartX); stripe < drawEndX; stripe++) {
                    if (stripe >= 0 && stripe < SCREEN_WIDTH && transformY < zBuffer[stripe]) {
                        let texX = Math.floor((stripe - (-spriteWidth / 2 + spriteScreenX)) * spriteSize / spriteWidth);
                        ctx.drawImage(batmanCanvas, texX, 0, 1, spriteSize, stripe, drawStartY, 1, drawEndY - drawStartY);
                    }
                }
            }
        }
        drawSlingshot();
    }

    function drawSlingshot() {
        let centerX = SCREEN_WIDTH / 2; let baseY = SCREEN_HEIGHT;
        let swayX = 0; let swayY = 0;
        if (!gameOver && (keys.w || keys.s || keys.a || keys.d || touchMoveX !== 0 || touchMoveY !== 0)) { swayX = Math.sin(Date.now() / 150) * 5; swayY = Math.abs(Math.cos(Date.now() / 150)) * 3; }
        let handX = centerX + swayX; let handY = baseY - swayY;
        ctx.fillStyle = '#4a3b2b'; ctx.fillRect(handX - 5, handY - 60, 10, 60); 
        ctx.beginPath(); ctx.lineWidth = 6; ctx.strokeStyle = '#4a3b2b'; ctx.moveTo(handX, handY - 60); ctx.lineTo(handX - 25, handY - 100); ctx.moveTo(handX, handY - 60); ctx.lineTo(handX + 25, handY - 100); ctx.stroke();
        let elasticCenterY = isShooting ? handY - 100 : handY - 65;
        ctx.beginPath(); ctx.lineWidth = 3; ctx.strokeStyle = '#777'; ctx.moveTo(handX - 25, handY - 100); ctx.lineTo(handX, elasticCenterY); ctx.lineTo(handX + 25, handY - 100); ctx.stroke();
        if (!isShooting && !rockFlying) { ctx.fillStyle = '#aaa'; ctx.beginPath(); ctx.arc(handX, elasticCenterY, 6, 0, Math.PI*2); ctx.fill(); }
        if (rockFlying) { rockSize -= 0.3; rockY -= 5; ctx.fillStyle = '#ccc'; ctx.beginPath(); ctx.arc(centerX, rockY, Math.max(1, rockSize), 0, Math.PI*2); ctx.fill(); if (rockSize <= 0) rockFlying = false; }
    }

    gameLoop();
</script>
</body>
</html>