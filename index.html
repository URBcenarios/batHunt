<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bat-Hunt</title>
    <style>
        /* CONFIGURA√á√ÉO VISUAL (CSS) */
        body {
            margin: 0; padding: 0; background-color: #000; overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; user-select: none; -webkit-user-select: none;
        }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }
        .hud-top {
            display: flex; justify-content: space-between; align-items: center; padding: 15px;
            color: #FFD700; font-weight: bold; font-size: 16px; text-shadow: 2px 2px 0px #000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        }
        .hud-info { display: flex; flex-direction: column; align-items: flex-end; }
        #timer-display {
            font-size: 24px; color: #fff; border: 2px solid #fff; padding: 5px 10px;
            background: rgba(0,0,0,0.5); border-radius: 5px; margin-top: 5px;
        }
        .crosshair {
            position: absolute; top: 60%; left: 50%; width: 2px; height: 2px;
            background-color: #FF0000; border: 1px solid #FFD700;
            transform: translate(-50%, -50%); border-radius: 50%; box-shadow: 0 0 4px #FFD700;
        }
        .controls-area {
            position: absolute; bottom: 30px; width: 100%; height: 180px;
            display: flex; justify-content: space-between; padding: 0 40px;
            box-sizing: border-box; pointer-events: none;
        }
        .joystick-base {
            width: 140px; height: 140px; background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 215, 0, 0.5); border-radius: 50%;
            position: relative; pointer-events: auto; align-self: flex-end;
        }
        .joystick-stick {
            width: 60px; height: 60px; background: rgba(80, 80, 80, 0.8);
            border: 2px solid #FFD700; border-radius: 50%; position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; box-shadow: 0 0 10px #000;
        }
        #fire-btn {
            width: 100px; height: 100px; background: rgba(200, 0, 0, 0.6);
            border: 4px solid #ff5555; border-radius: 50%; pointer-events: auto;
            align-self: flex-end; margin-bottom: 20px; display: flex;
            align-items: center; justify-content: center; font-size: 20px;
            color: white; text-shadow: 1px 1px 2px black; font-weight: bold;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
        }
        #fire-btn:active { background: rgba(255, 0, 0, 0.8); transform: scale(0.95); }
        #overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.95); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100; pointer-events: auto;
        }
        #action-btn {
            padding: 20px 40px; font-size: 24px; background-color: #FFD700; color: #000;
            border: 4px solid #fff; font-family: 'Courier New', Courier, monospace;
            font-weight: bold; cursor: pointer; box-shadow: 0 0 20px #FFD700;
            animation: pulse 1.5s infinite; margin-top: 20px;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        #alert-msg {
            position: absolute; top: 40%; width: 100%; text-align: center;
            color: #FF0000; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 0px #fff; display: none; z-index: 95;
        }
    </style>
</head>
<body>

    <div id="overlay-screen">
        <h1 id="title-text" style="color:#FFD700; margin-bottom:10px; text-shadow: 2px 2px #000; font-size: 40px; text-align: center;">BAT-HUNT<br><span style="color:#fff; font-size: 20px;">ARCADE MODE</span></h1>
        <div id="level-info" style="color:#aaa; text-align:center;">Toque para come√ßar<br>Ative o som üîä</div>
        <div id="action-btn">INICIAR</div>
    </div>

    <div id="alert-msg">PRECISA DE 80% DOS ALVOS!</div>

    <div id="ui-layer">
        <div class="hud-top">
            <div>
                <span id="level-display" style="display:block; color:#fff; font-size:14px;">N√çVEL 1</span>
                <span id="score-display">ALVOS: 0/15</span>
            </div>
            <div class="hud-info">
                <span style="font-size:12px; color:#aaa;">TEMPO</span>
                <span id="timer-display">00:00</span>
            </div>
        </div>
        
        <div id="crosshair" class="crosshair"></div>

        <div class="controls-area">
            <div id="joy-left" class="joystick-base">
                <div id="stick-left" class="joystick-stick"></div>
            </div>
            <div id="fire-btn">TIRO</div>
        </div>
    </div>

    <canvas id="gameCanvas" width="320" height="240"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Refer√™ncias UI
    const scoreDisplay = document.getElementById('score-display');
    const timerDisplay = document.getElementById('timer-display');
    const levelDisplay = document.getElementById('level-display');
    const crosshair = document.getElementById('crosshair');
    const overlayScreen = document.getElementById('overlay-screen');
    const titleText = document.getElementById('title-text');
    const levelInfo = document.getElementById('level-info');
    const actionBtn = document.getElementById('action-btn');
    const alertMsg = document.getElementById('alert-msg');
    const joyLeftBase = document.getElementById('joy-left');
    const stickLeft = document.getElementById('stick-left');
    const fireBtn = document.getElementById('fire-btn');

    const SCREEN_WIDTH = 320;
    const SCREEN_HEIGHT = 240;
    const spriteSize = 64;
    
    // --- SPRITES ---
    // 1. BATMAN
    const batmanCanvas = document.createElement('canvas');
    batmanCanvas.width = spriteSize; batmanCanvas.height = spriteSize;
    const bCtx = batmanCanvas.getContext('2d');
    bCtx.fillStyle = '#000'; bCtx.beginPath(); bCtx.moveTo(16, 20); bCtx.lineTo(48, 20); bCtx.lineTo(54, 60); bCtx.lineTo(32, 55); bCtx.lineTo(10, 60); bCtx.fill();
    bCtx.fillStyle = '#444'; bCtx.fillRect(20, 20, 24, 30);
    bCtx.fillStyle = '#000'; bCtx.beginPath(); bCtx.moveTo(22, 20); bCtx.lineTo(22, 8); bCtx.lineTo(26, 12); bCtx.lineTo(38, 12); bCtx.lineTo(42, 8); bCtx.lineTo(42, 20); bCtx.fill(); bCtx.fillRect(22, 12, 20, 14);
    bCtx.fillStyle = '#FFD700'; bCtx.fillRect(20, 48, 24, 4);
    bCtx.beginPath(); bCtx.ellipse(32, 30, 8, 5, 0, 0, Math.PI * 2); bCtx.fill();
    bCtx.fillStyle = '#000'; bCtx.beginPath(); bCtx.moveTo(26,28); bCtx.lineTo(38,28); bCtx.lineTo(32,33); bCtx.fill();
    bCtx.fillStyle = '#fff'; bCtx.fillRect(26, 16, 4, 2); bCtx.fillRect(34, 16, 4, 2);
    bCtx.fillStyle = '#F1C27D'; bCtx.fillRect(28, 22, 8, 4);

    // 2. SWITCH
    const switchCanvas = document.createElement('canvas');
    switchCanvas.width = 64; switchCanvas.height = 64;
    const sCtx = switchCanvas.getContext('2d');
    sCtx.fillStyle = '#888'; sCtx.fillRect(10, 10, 44, 44);
    sCtx.fillStyle = '#555'; sCtx.fillRect(14, 14, 36, 36); 
    sCtx.fillStyle = '#aa0000'; sCtx.beginPath(); sCtx.arc(32, 32, 10, 0, Math.PI*2); sCtx.fill();
    sCtx.fillStyle = '#fff'; sCtx.font = "bold 10px Arial"; sCtx.fillText("EXIT", 22, 58);

    // 3. ATIRADEIRA DE MADEIRA 2D
    const slingSpriteSize = 64;
    const slingCanvas = document.createElement('canvas');
    slingCanvas.width = slingSpriteSize; slingCanvas.height = slingSpriteSize;
    const slCtx = slingCanvas.getContext('2d');
    const woodDark = '#3e2723'; const woodMedium = '#5d4037';
    slCtx.fillStyle = woodMedium; slCtx.beginPath();
    slCtx.moveTo(28, 64); slCtx.lineTo(36, 64); slCtx.lineTo(36, 40); // Base
    slCtx.lineTo(58, 10); slCtx.lineTo(50, 10); slCtx.lineTo(32, 35); // Bra√ßo Dir
    slCtx.lineTo(14, 10); slCtx.lineTo(6, 10); slCtx.lineTo(28, 40); // Bra√ßo Esq
    slCtx.closePath(); slCtx.fill();
    slCtx.strokeStyle = woodDark; slCtx.lineWidth = 2; slCtx.stroke(); // Contorno
    slCtx.fillStyle = woodDark; slCtx.fillRect(6, 10, 8, 5); slCtx.fillRect(50, 10, 8, 5); // Amarras

    const PALETTE = { floor: '#1a1a1a', skyTop: '#050505', skyBottom: '#202020', wallGray: '#555', wallGrayDark: '#333', finish: '#444' };

    let posX = 2, posY = 2; 
    let dirX = 0, dirY = -1; 
    let planeX = -0.66, planeY = 0;

    let currentLevel = 1;
    let kills = 0; 
    let totalTargets = 0;
    let moveSpeed = 0.10; 
    let rotSpeed = 0.030; 
    let isPlaying = false;
    let timeLeft = 0;
    let lastTime = Date.now();

    const mapSize = 50; 
    let worldMap = []; 
    let sprites = []; 
    let zBuffer = new Array(SCREEN_WIDTH).fill(0);

    let isShooting = false;
    let shootFrame = 0;
    let rockFlying = false;
    let rockSize = 0;
    let rockY = 0;

    // --- GERADOR DE N√çVEL ---
    function generateLevel(level) {
        let difficulty = Math.min(level, 10);
        totalTargets = Math.floor(15 - (difficulty * 0.7)); 
        totalTargets = Math.max(5, totalTargets);
        let baseTime = 60; 
        timeLeft = baseTime + (totalTargets * 10); 

        worldMap = [];
        for(let x=0; x<mapSize; x++) { worldMap[x] = []; for(let y=0; y<mapSize; y++) { worldMap[x][y] = 1; } }

        let digX = Math.floor(mapSize/2); let digY = Math.floor(mapSize/2);
        let steps = 200 + (level * 30); 
        let straightnessMin = Math.max(2, 10 - difficulty);
        let straightnessMax = Math.max(4, 15 - difficulty);

        worldMap[digX][digY] = 0; 
        posX = digX + 0.5; posY = digY + 0.5; 

        const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:1, y:0}, {x:-1, y:0}]; 
        
        for(let i=0; i<steps; i++) {
            let d = dirs[Math.floor(Math.random() * dirs.length)];
            let length = Math.floor(Math.random() * (straightnessMax - straightnessMin)) + straightnessMin;
            for(let j=0; j<length; j++) {
                digX += d.x; digY += d.y;
                if(digX < 2) digX = 2; if(digX > mapSize-3) digX = mapSize-3;
                if(digY < 2) digY = 2; if(digY > mapSize-3) digY = mapSize-3;
                worldMap[digX][digY] = 0;
                if(Math.random() < (0.9 - (difficulty * 0.08))) { 
                    if (digX+1 < mapSize-1) worldMap[digX+1][digY] = 0;
                    if (digY+1 < mapSize-1) worldMap[digX][digY+1] = 0;
                    if (digX-1 > 1) worldMap[digX-1][digY] = 0;
                }
            }
        }

        sprites = [];
        let targetsPlaced = 0;
        let safetyCounter = 0;
        while(targetsPlaced < totalTargets && safetyCounter < 3000) {
            let rx = Math.floor(Math.random() * mapSize);
            let ry = Math.floor(Math.random() * mapSize);
            if(worldMap[rx][ry] === 0) {
                let minSpawnDist = 5 + (level * 2);
                let distToPlayer = Math.hypot(rx - posX, ry - posY);
                if(distToPlayer > minSpawnDist) {
                    sprites.push({ x: rx + 0.5, y: ry + 0.5, type: 0, active: true });
                    targetsPlaced++;
                }
            }
            safetyCounter++;
        }

        let bestExitX = posX, bestExitY = posY;
        let maxDist = 0;
        for(let x=1; x<mapSize-1; x++) {
            for(let y=1; y<mapSize-1; y++) {
                if(worldMap[x][y] === 0) {
                    if(worldMap[x+1][y]===1 || worldMap[x-1][y]===1 || worldMap[x][y+1]===1 || worldMap[x][y-1]===1) {
                        let d = Math.hypot(x - posX, y - posY);
                        if(d > maxDist) { maxDist = d; bestExitX = x; bestExitY = y; }
                    }
                }
            }
        }
        sprites.push({ x: bestExitX + 0.5, y: bestExitY + 0.5, type: 1, active: true });

        kills = 0; dirX = 0; dirY = -1; planeX = -0.66; planeY = 0;
        scoreDisplay.innerText = `ALVOS: 0/${totalTargets}`;
        levelDisplay.innerText = `N√çVEL ${level}`;
    }

    // --- √ÅUDIO ---
    let audioCtx = null; let isMusicPlaying = false;
    function unlockAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    function playBatTheme() {
        if (!audioCtx || !isPlaying) return;
        let timeRatio = 1 - (Math.max(0, timeLeft) / (timeLeft + 30));
        if (timeLeft < 30) timeRatio = 0.8; 
        const tempo = 100 + (timeRatio * 100);
        const noteDuration = 60 / tempo / 2;
        const notes = [246.94, 246.94, 246.94, 246.94, 233.08, 233.08, 233.08, 233.08, 220.00, 220.00, 220.00, 220.00, 207.65, 207.65, 207.65, 207.65];
        let time = audioCtx.currentTime;
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); 
            osc.type = 'sawtooth'; osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.05, time + i * noteDuration); 
            gain.gain.exponentialRampToValueAtTime(0.01, time + i * noteDuration + (noteDuration * 0.8));
            osc.connect(gain); gain.connect(audioCtx.destination); 
            osc.start(time + i * noteDuration); osc.stop(time + i * noteDuration + noteDuration);
        });
        if(isPlaying) setTimeout(playBatTheme, (notes.length * noteDuration * 1000)); 
    }
// 1. O Grunhido (Impacto)
    function playHitSound() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        // 'triangle' tem um som mais "sujo" que o 'sine', bom para impacto 8-bit
        osc.type = 'triangle'; 
        
        // O som come√ßa em 200Hz e cai para 50Hz em 0.15 segundos (efeito de queda)
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.linearRampToValueAtTime(50, t + 0.15); 
        
        // O volume come√ßa alto e zera r√°pido
        gain.gain.setValueAtTime(0.3, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.15);
        
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + 0.15);
    }
// 2. O Ding (Vit√≥ria/Passar de Fase)
    function playWinSound() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        
        // Sequ√™ncia de notas (C Maior): C5, E5, G5, C6 (Oitava acima)
        const notes = [523.25, 659.25, 783.99, 1046.50]; 
        
        notes.forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            // 'square' (onda quadrada) tem aquele som "crocante" de Nintendinho
            osc.type = 'square'; 
            osc.frequency.value = freq;
            
            // Toca cada nota 0.1s depois da anterior (efeito escadinha)
            const startTime = t + (i * 0.1);
            const duration = 0.4; // A √∫ltima nota ecoa um pouco mais
            
            // Envelope de volume: Come√ßa forte e desaparece
            gain.gain.setValueAtTime(0.15, startTime);
            gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start(startTime);
            osc.stop(startTime + duration);
        });
    }

    // --- FLUXO ---
    actionBtn.addEventListener('click', startLevelAction);
    actionBtn.addEventListener('touchend', (e) => { e.preventDefault(); startLevelAction(); });

    function startLevelAction() {
        unlockAudio();
        if(currentLevel === 1 || !isPlaying) {
            isMusicPlaying = true;
            setTimeout(playBatTheme, 500);
        }
        generateLevel(currentLevel);
        overlayScreen.style.display = 'none';
        lastTime = Date.now();
        isPlaying = true; 
        requestAnimationFrame(gameLoop);
    }

    function levelComplete() {
        playWinSound(); isPlaying = false; currentLevel++; 
        let nextTargets = Math.floor(15 - (Math.min(currentLevel, 10) * 0.7));
        nextTargets = Math.max(5, nextTargets);
        titleText.innerHTML = `<span style="color:#00FF00">N√çVEL ${currentLevel-1} CONCLU√çDO!</span>`;
        levelInfo.innerHTML = `<p>Excelente trabalho.</p><p>Pr√≥ximo N√≠vel: ${nextTargets} Alvos</p>`;
        actionBtn.innerText = "PR√ìXIMA FASE";
        overlayScreen.style.display = 'flex';
    }

    function gameOverFunc() {
        isPlaying = false;
        titleText.innerHTML = `<span style="color:#FF0000">GAME OVER</span>`;
        levelInfo.innerHTML = `<p>O tempo acabou.</p><p>Voc√™ chegou ao N√≠vel ${currentLevel}</p>`;
        actionBtn.innerText = "TENTAR NOVAMENTE";
        currentLevel = 1; overlayScreen.style.display = 'flex';
    }

    // --- CONTROLES ---
    let inputMove = 0; let inputTurn = 0; 
    let joyTouchId = null; let joyStartX = 0, joyStartY = 0;
    joyLeftBase.addEventListener('touchstart', (e) => { e.preventDefault(); let t = e.changedTouches[0]; joyTouchId = t.identifier; let rect = joyLeftBase.getBoundingClientRect(); joyStartX = rect.left + rect.width/2; joyStartY = rect.top + rect.height/2; updateJoystick(t.clientX, t.clientY); });
    joyLeftBase.addEventListener('touchmove', (e) => { e.preventDefault(); for(let i=0; i<e.changedTouches.length; i++) { if(e.changedTouches[i].identifier === joyTouchId) updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY); } });
    joyLeftBase.addEventListener('touchend', (e) => { e.preventDefault(); resetJoystick(); });
    function updateJoystick(clientX, clientY) {
        let dx = clientX - joyStartX; let dy = clientY - joyStartY;
        let dist = Math.sqrt(dx*dx + dy*dy); let maxDist = 50;
        if(dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
        stickLeft.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        inputMove = -dy / maxDist; inputTurn = dx / maxDist;  
    }
    function resetJoystick() { joyTouchId = null; stickLeft.style.transform = `translate(-50%, -50%)`; inputMove = 0; inputTurn = 0; }
    fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); fireBtn.style.backgroundColor = "rgba(255,0,0,0.9)"; playerShoot(); });
    fireBtn.addEventListener('touchend', (e) => { e.preventDefault(); fireBtn.style.backgroundColor = "rgba(200,0,0,0.6)"; });
    const keys = { w:false, s:false, a:false, d:false };
    document.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; if(e.code==="Space") playerShoot(); });
    document.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });

    // --- TIRO ---
    function playerShoot() { 
        if (!isPlaying || isShooting) return; 
        isShooting = true; shootFrame = 10; rockFlying = true; rockSize = 6; rockY = SCREEN_HEIGHT - 60;
        sprites.sort((a, b) => { return ((posX - a.x)*(posX - a.x) + (posY - a.y)*(posY - a.y)) - ((posX - b.x)*(posX - b.x) + (posY - b.y)*(posY - b.y)); });
        for(let i=0; i<sprites.length; i++) {
            let s = sprites[i]; if (!s.active) continue;
            let spriteX = s.x - posX; let spriteY = s.y - posY;
            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 
            if (transformY > 0) {
                let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
                let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
                let offset = (SCREEN_WIDTH / 2) - (spriteScreenX - spriteWidth / 2);
                let texX = Math.floor(offset * spriteSize / spriteWidth);
                if (texX > 10 && texX < 54) {
                    if (transformY < zBuffer[Math.floor(SCREEN_WIDTH/2)] + 0.5 && transformY < 15) {
                        if (s.type === 0) { 
                            setTimeout(() => { 
                                if(s.active) { s.active = false; kills++; scoreDisplay.innerText = `ALVOS: ${kills}/${totalTargets}`; flashCrosshair(); playHitSound(); }
                            }, 100); 
                        } else if (s.type === 1) { 
                             let needed = Math.ceil(totalTargets * 0.8);
                             if (kills >= needed) { setTimeout(() => { levelComplete(); }, 100); } 
                             else { alertMsg.style.display = 'block'; alertMsg.innerText = `FALTAM ALVOS! (${kills}/${needed})`; setTimeout(() => { alertMsg.style.display = 'none'; }, 2000); }
                        }
                        break; 
                    }
                }
            }
        }
    }
    function flashCrosshair() { crosshair.style.backgroundColor = '#FFD700'; crosshair.style.transform = 'translate(-50%, -50%) scale(2.5)'; setTimeout(() => { crosshair.style.backgroundColor = '#FF0000'; crosshair.style.transform = 'translate(-50%, -50%) scale(1)'; }, 150); }
    function formatTime(seconds) { let m = Math.floor(seconds / 60); let s = Math.floor(seconds % 60); return `${m < 10 ? '0'+m : m}:${s < 10 ? '0'+s : s}`; }
    
    // --- LOOP ---
    function gameLoop() { 
        if (isPlaying) { 
            let now = Date.now(); let dt = (now - lastTime) / 1000; lastTime = now;
            timeLeft -= dt;
            timerDisplay.innerText = formatTime(Math.max(0, timeLeft));
            if (timeLeft < 30) { timerDisplay.style.color = '#FF0000'; timerDisplay.style.borderColor = '#FF0000'; }
            else if (timeLeft < 60) { timerDisplay.style.color = '#FFFF00'; timerDisplay.style.borderColor = '#FFFF00'; }
            if (timeLeft <= 0) { timeLeft = 0; gameOverFunc(); }
            let kbTurn = 0; if (keys.d) kbTurn = 1; if (keys.a) kbTurn = -1;
            let kbMove = 0; if (keys.w) kbMove = 1; if (keys.s) kbMove = -1;
            let turnVal = inputTurn + kbTurn;
            let moveVal = inputMove + kbMove;
            if (Math.abs(turnVal) > 0.1) {
                let rot = -turnVal * rotSpeed; 
                let oldDirX = dirX; dirX = dirX * Math.cos(rot) - dirY * Math.sin(rot); dirY = oldDirX * Math.sin(rot) + dirY * Math.cos(rot); 
                let oldPlaneX = planeX; planeX = planeX * Math.cos(rot) - planeY * Math.sin(rot); planeY = oldPlaneX * Math.sin(rot) + planeY * Math.cos(rot); 
            }
            if (Math.abs(moveVal) > 0.1) {
                let speed = moveVal * moveSpeed; 
                if(worldMap[Math.floor(posX + dirX * speed)][Math.floor(posY)] <= 0) posX += dirX * speed; 
                if(worldMap[Math.floor(posX)][Math.floor(posY + dirY * speed)] <= 0) posY += dirY * speed; 
            }
        } 
        if (shootFrame > 0) shootFrame--; else isShooting = false; 
        draw(); requestAnimationFrame(gameLoop); 
    }

    // --- RENDER ---
    function draw() {
        if(worldMap.length === 0) return;
        let gradientSky = ctx.createLinearGradient(0, 0, 0, SCREEN_HEIGHT/2); gradientSky.addColorStop(0, PALETTE.skyTop); gradientSky.addColorStop(1, PALETTE.skyBottom);
        ctx.fillStyle = gradientSky; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
        ctx.fillStyle = PALETTE.floor; ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
        zBuffer.fill(1000); 
        for (let x = 0; x < SCREEN_WIDTH; x++) { 
            let cameraX = 2 * x / SCREEN_WIDTH - 1; let rayDirX = dirX + planeX * cameraX; let rayDirY = dirY + planeY * cameraX;
            let mapX = Math.floor(posX), mapY = Math.floor(posY);
            let sideDistX, sideDistY, deltaDistX = Math.abs(1 / rayDirX), deltaDistY = Math.abs(1 / rayDirY);
            let stepX, stepY, hit = 0, side;
            if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX) * deltaDistX; } else { stepX = 1; sideDistX = (mapX + 1.0 - posX) * deltaDistX; }
            if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY) * deltaDistY; } else { stepY = 1; sideDistY = (mapY + 1.0 - posY) * deltaDistY; }
            while (hit === 0) {
                if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; } else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                if (worldMap[mapX][mapY] > 0) { hit = 1; }
            }
            let perpWallDist = side === 0 ? (mapX - posX + (1 - stepX) / 2) / rayDirX : (mapY - posY + (1 - stepY) / 2) / rayDirY;
            zBuffer[x] = perpWallDist; 
            let lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
            let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2; if (drawStart < 0) drawStart = 0;
            let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2; if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;
            let color = side === 1 ? PALETTE.wallGrayDark : PALETTE.wallGray;
            ctx.fillStyle = color; ctx.globalAlpha = Math.max(0.1, 1 - perpWallDist / 30); ctx.fillRect(x, drawStart, 1, drawEnd - drawStart); ctx.globalAlpha = 1.0;
        }
        
        let spriteOrder = [];
        for(let i=0; i<sprites.length; i++) {
            if(!sprites[i].active) continue;
            let dist = ((posX - sprites[i].x)*(posX - sprites[i].x) + (posY - sprites[i].y)*(posY - sprites[i].y));
            spriteOrder.push({ id: i, dist: dist });
        }
        spriteOrder.sort((a,b) => b.dist - a.dist);
        for(let i=0; i<spriteOrder.length; i++) {
            let sprite = sprites[spriteOrder[i].id];
            let spriteX = sprite.x - posX; let spriteY = sprite.y - posY;
            let invDet = 1.0 / (planeX * dirY - dirX * planeY);
            let transformX = invDet * (dirY * spriteX - dirX * spriteY);
            let transformY = invDet * (-planeY * spriteX + planeX * spriteY); 
            if (transformY > 0) { 
                let spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
                let spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY)); 
                let drawStartY = -spriteHeight / 2 + SCREEN_HEIGHT / 2 + (spriteHeight * 0.25); if (drawStartY < 0) drawStartY = 0;
                let drawEndY = drawStartY + spriteHeight; if (drawEndY >= SCREEN_HEIGHT) drawEndY = SCREEN_HEIGHT - 1;
                let spriteWidth = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
                let drawStartX = -spriteWidth / 2 + spriteScreenX; let drawEndX = spriteWidth / 2 + spriteScreenX;
                for(let stripe = Math.floor(drawStartX); stripe < drawEndX; stripe++) {
                    if (stripe >= 0 && stripe < SCREEN_WIDTH && transformY < zBuffer[stripe]) {
                        let texX = Math.floor((stripe - (-spriteWidth / 2 + spriteScreenX)) * spriteSize / spriteWidth);
                        let sourceCanvas = sprite.type === 0 ? batmanCanvas : switchCanvas;
                        ctx.drawImage(sourceCanvas, texX, 0, 1, spriteSize, stripe, drawStartY, 1, drawEndY - drawStartY);
                    }
                }
            }
        }
        drawSlingshot();
    }

    // --- FUN√á√ÉO DESENHAR ATIRADEIRA REVISADA ---
    function drawSlingshot() {
        if(!isPlaying && !gameOver) return;
        let centerX = SCREEN_WIDTH / 2; let baseY = SCREEN_HEIGHT;
        let swayX = 0; let swayY = 0;

        // BALAN√áO DA ARMA (RESTAURADO E AUMENTADO)
        if (isPlaying && (inputMove !== 0 || inputTurn !== 0)) {
            swayX = Math.sin(Date.now() / 150) * 12; 
            swayY = Math.abs(Math.cos(Date.now() / 150)) * 8;
        }

        // TAMANHO E POSI√á√ÉO AJUSTADOS
        const drawnSize = 110; // Menor que antes (era 160)
        const baseOffset = 60; // Empurra bem para baixo na tela
        let handX = centerX + swayX;
        let handY = baseY + baseOffset - swayY;

        // 1. DESENHAR O SPRITE DE MADEIRA
        ctx.drawImage(slingCanvas, handX - drawnSize/2, handY - drawnSize, drawnSize, drawnSize);

        // 2. DESENHAR O EL√ÅSTICO E PEDRA (Recalculado para o novo tamanho)
        let tipLeftX = handX - (drawnSize * 0.35); 
        let tipRightX = handX + (drawnSize * 0.35); 
        let tipsY = handY - (drawnSize * 0.82); 

        let elasticCenterY = tipsY + (drawnSize * 0.15);
        if (isShooting) elasticCenterY = tipsY - (drawnSize * 0.05);

        ctx.beginPath(); ctx.lineWidth = 3; ctx.strokeStyle = '#555'; ctx.lineCap = 'round';
        ctx.moveTo(tipLeftX, tipsY); ctx.lineTo(handX, elasticCenterY); ctx.lineTo(tipRightX, tipsY); ctx.stroke();

        if (!isShooting && !rockFlying) {
            let rSize = drawnSize * 0.05;
            ctx.fillStyle = '#999'; ctx.beginPath(); ctx.arc(handX, elasticCenterY, rSize, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#ccc'; ctx.beginPath(); ctx.arc(handX-1, elasticCenterY-1, rSize/2, 0, Math.PI*2); ctx.fill();
        }

        if (rockFlying) {
            if(rockSize === 6) rockY = tipsY;
            rockSize -= 0.3; rockY -= 6; 
            ctx.fillStyle = '#999'; ctx.beginPath(); ctx.arc(centerX, rockY, Math.max(1, rockSize), 0, Math.PI*2); ctx.fill();
            if (rockSize <= 0) rockFlying = false;
        }
    }

    gameLoop();
</script>
</body>
</html>